import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import { sendMail } from '@/lib/email';

// Fonction pour d√©tecter les emails auto-g√©n√©r√©s (format: ObjectId@monmariage.ai)
// Ces emails sont cr√©√©s lors de l'import de prestataires et ne sont pas de vraies adresses
function isAutoGeneratedEmail(email: string | null | undefined): boolean {
  if (!email) return true;
  // Pattern: 24 caract√®res hexad√©cimaux suivis de @monmariage.ai
  const autoGenPattern = /^[a-f0-9]{24}@monmariage\.ai$/i;
  return autoGenPattern.test(email);
}

export async function POST(request: NextRequest) {
  try {

    // V√©rifier que l'utilisateur est connect√©
    const session = await getServerSession(authOptions);

    if (!session?.user) {

      return NextResponse.json(
        { error: 'Vous devez √™tre connect√© pour envoyer une demande de devis' },
        { status: 401 }
      );
    }

    const body = await request.json();

    const {
      eventDate,
      guestCount,
      eventType,
      venueLocation,
      budget,
      message,
      storefrontId,
      storefrontName,
      storefrontEmail,
    } = body;

    // Validate required fields
    if (!eventDate || !guestCount || !eventType || !venueLocation || !budget) {
      return NextResponse.json(
        { error: 'Tous les champs obligatoires doivent √™tre remplis' },
        { status: 400 }
      );
    }

    // V√©rifier que la vitrine partenaire existe (vers laquelle l'utilisateur envoie sa demande)
    const storefront = await prisma.partnerStorefront.findUnique({
      where: { id: storefrontId },
      include: { 
        partner: {
          include: {
            user: true
          }
        }
      }
    });
    
    if (!storefront) {

      return NextResponse.json(
        { error: 'Vitrine partenaire non trouv√©e' },
        { status: 400 }
      );
    }

    // Email du partenaire qui recevra la demande
    // Si l'email du prestataire n'est pas disponible ou est auto-g√©n√©r√©, utiliser les emails de fallback
    const FALLBACK_EMAILS = ['jf@monmariage.ai', 'arnaud@monmariage.ai'];
    const rawPartnerEmail = storefrontEmail || storefront.partner?.user?.email;
    const isAutoGenerated = isAutoGeneratedEmail(rawPartnerEmail);
    const partnerEmail = isAutoGenerated ? null : rawPartnerEmail;
    const isUsingFallback = !partnerEmail;

    // Construire les informations de r√©f√©rence si fallback
    const partnerName = storefront.partner?.companyName || storefrontName || 'Prestataire inconnu';
    const storefrontType = storefront.type; // 'VENUE' ou 'PARTNER'

    // Create quote request record in database
    const quoteRequest = await prisma.quoteRequest.create({
      data: {
        // Utiliser les informations de l'utilisateur connect√©
        firstName: session.user.name?.split(' ')[0] || 'Utilisateur',
        lastName: session.user.name?.split(' ').slice(1).join(' ') || 'MonMariage.ai',
        email: session.user.email || '',
        phone: null, // Pas de t√©l√©phone dans le nouveau formulaire
        eventDate: new Date(eventDate),
        guestCount,
        eventType,
        venueLocation,
        budget,
        message: message || null,
        storefrontId,
        status: 'PENDING',
      },
    });

    // Log de la demande de devis avec informations de r√©f√©rence
    if (isUsingFallback) {
      const fallbackReason = isAutoGenerated
        ? `Email auto-g√©n√©r√© d√©tect√© (${rawPartnerEmail})`
        : 'Email prestataire non disponible';
      console.log(`[QUOTE-REQUEST] ‚ö†Ô∏è ${fallbackReason} - Utilisation du fallback`);
      console.log('[QUOTE-REQUEST] üìß Emails de destination:', FALLBACK_EMAILS);
      console.log('[QUOTE-REQUEST] üìã R√©f√©rence demande:', {
        quoteRequestId: quoteRequest.id,
        storefrontId: storefrontId,
        storefrontType: storefrontType,
        partnerName: partnerName,
        clientId: session.user.id,
        clientEmail: session.user.email,
        clientName: session.user.name,
        originalEmail: rawPartnerEmail,
        isAutoGenerated: isAutoGenerated,
      });

      // Envoyer un email √† tous les fallbacks avec les informations de r√©f√©rence
      const typeLabel = storefrontType === 'VENUE' ? 'Lieu' : 'Prestataire';
      const emailHtml = `
        <h2>Nouvelle demande de devis</h2>
        <p><strong>‚ö†Ô∏è ${isAutoGenerated ? 'Email auto-g√©n√©r√© (prestataire import√©)' : 'Email du prestataire non disponible'}</strong></p>
        ${isAutoGenerated ? `<p><em>Email original: ${rawPartnerEmail}</em></p>` : ''}

        <h3>Informations de r√©f√©rence</h3>
        <ul>
          <li><strong>ID Demande:</strong> ${quoteRequest.id}</li>
          <li><strong>Type:</strong> ${typeLabel}</li>
          <li><strong>Nom du ${typeLabel.toLowerCase()}:</strong> ${partnerName}</li>
          <li><strong>ID Storefront:</strong> ${storefrontId}</li>
        </ul>

        <h3>Client</h3>
        <ul>
          <li><strong>ID Client:</strong> ${session.user.id}</li>
          <li><strong>Nom:</strong> ${session.user.name || 'Non renseign√©'}</li>
          <li><strong>Email:</strong> ${session.user.email || 'Non renseign√©'}</li>
        </ul>

        <h3>D√©tails de la demande</h3>
        <ul>
          <li><strong>Date de l'√©v√©nement:</strong> ${new Date(eventDate).toLocaleDateString('fr-FR')}</li>
          <li><strong>Nombre d'invit√©s:</strong> ${guestCount}</li>
          <li><strong>Type d'√©v√©nement:</strong> ${eventType}</li>
          <li><strong>Lieu:</strong> ${venueLocation}</li>
          <li><strong>Budget:</strong> ${budget}</li>
        </ul>

        ${message ? `<h3>Message du client</h3><p>${message}</p>` : ''}

        <hr>
        <p><em>Email envoy√© automatiquement car l'email du prestataire n'est pas configur√©.</em></p>
      `;

      // Envoyer √† tous les emails de fallback
      for (const fallbackEmail of FALLBACK_EMAILS) {
        try {
          await sendMail({
            to: fallbackEmail,
            subject: `[MonMariage.ai] Nouvelle demande de devis - ${partnerName}`,
            html: emailHtml
          });
          console.log('[QUOTE-REQUEST] üìß Email envoy√© √†:', fallbackEmail);
        } catch (emailError) {
          console.error('[QUOTE-REQUEST] ‚ùå Erreur envoi email √†', fallbackEmail, ':', emailError);
        }
      }
    } else {
      // Le partenaire a un email, lui envoyer directement
      const partnerEmailHtml = `
        <h2>Nouvelle demande de devis</h2>
        <p>Vous avez re√ßu une nouvelle demande de devis pour <strong>${partnerName}</strong>.</p>

        <h3>Client</h3>
        <ul>
          <li><strong>Nom:</strong> ${session.user.name || 'Non renseign√©'}</li>
          <li><strong>Email:</strong> ${session.user.email || 'Non renseign√©'}</li>
        </ul>

        <h3>D√©tails de la demande</h3>
        <ul>
          <li><strong>Date de l'√©v√©nement:</strong> ${new Date(eventDate).toLocaleDateString('fr-FR')}</li>
          <li><strong>Nombre d'invit√©s:</strong> ${guestCount}</li>
          <li><strong>Type d'√©v√©nement:</strong> ${eventType}</li>
          <li><strong>Lieu:</strong> ${venueLocation}</li>
          <li><strong>Budget:</strong> ${budget}</li>
        </ul>

        ${message ? `<h3>Message du client</h3><p>${message}</p>` : ''}

        <hr>
        <p><em>Vous pouvez r√©pondre directement √† cet email pour contacter le client.</em></p>
      `;

      try {
        await sendMail({
          to: partnerEmail,
          subject: `[MonMariage.ai] Nouvelle demande de devis - ${partnerName}`,
          html: partnerEmailHtml
        });
        console.log('[QUOTE-REQUEST] üìß Email envoy√© au partenaire:', partnerEmail);
      } catch (emailError) {
        console.error('[QUOTE-REQUEST] ‚ùå Erreur envoi email au partenaire:', emailError);
      }

      // Toujours envoyer une copie √† jahangeer@monmariage.ai
      try {
        await sendMail({
          to: 'jahangeer@monmariage.ai',
          subject: `[MonMariage.ai] Copie - Nouvelle demande de devis - ${partnerName}`,
          html: `
            <h2>Copie - Nouvelle demande de devis</h2>
            <p><strong>Email envoy√© au partenaire:</strong> ${partnerEmail}</p>
            ${partnerEmailHtml}
          `
        });
        console.log('[QUOTE-REQUEST] üìß Copie envoy√©e √† jahangeer@monmariage.ai');
      } catch (emailError) {
        console.error('[QUOTE-REQUEST] ‚ùå Erreur envoi copie √† jahangeer@monmariage.ai:', emailError);
      }
    }

    return NextResponse.json({
      success: true,
      message: 'Demande de devis envoy√©e avec succ√®s',
      quoteRequestId: quoteRequest.id
    });

  } catch (error) {
    console.error('[QUOTE-REQUEST] Erreur d√©taill√©e:', error);
    console.error('[QUOTE-REQUEST] Type d\'erreur:', typeof error);
    console.error('[QUOTE-REQUEST] Message d\'erreur:', error instanceof Error ? error.message : String(error));
    console.error('[QUOTE-REQUEST] Stack trace:', error instanceof Error ? error.stack : 'Pas de stack trace');
    
    // Retourner l'erreur sp√©cifique en d√©veloppement
    if (process.env.NODE_ENV === 'development') {
      return NextResponse.json(
        { 
          error: 'Erreur interne du serveur',
          details: error instanceof Error ? error.message : String(error),
          stack: error instanceof Error ? error.stack : undefined
        },
        { status: 500 }
      );
    }
    
    return NextResponse.json(
      { error: 'Erreur interne du serveur' },
      { status: 500 }
    );
  }
} 