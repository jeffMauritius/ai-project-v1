import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

// Mapping des mots-cl√©s dans les descriptions vers les types de service corrects
const serviceTypeKeywords = {
  'OFFICIANT': ['officiant', 'c√©r√©monie', 'mariage civil', 'mariage religieux', 'union', 'c√©l√©bration'],
  'TRAITEUR': ['traiteur', 'cuisine', 'repas', 'menu', 'gastronomie', 'buffet', 'cocktail', 'vin', 'champagne'],
  'PHOTOGRAPHE': ['photographe', 'photo', 'photographie', 'reportage', 'clich√©', 's√©ance'],
  'MUSIQUE': ['musique', 'dj', 'musicien', 'orchestre', 'groupe', 'son', 'animation musicale', 'playlist'],
  'FLORISTE': ['fleuriste', 'fleurs', 'bouquet', 'd√©coration florale', 'roses', 'composition'],
  'DECORATION': ['d√©coration', 'd√©corateur', 'd√©coratrice', 'ambiance', 'mobilier', 'location', 'accessoires'],
  'VOITURE': ['voiture', 'v√©hicule', 'location', 'transport', 'limousine', 'collection', 'ancienne'],
  'VIDEO': ['vid√©o', 'vid√©aste', 'film', 'cin√©matographie', 'montage'],
  'WEDDING_CAKE': ['g√¢teau', 'p√¢tisserie', 'dessert', 'cake', 'sucr√©'],
  'ORGANISATION': ['organisation', 'planner', 'coordination', '√©v√©nementiel', 'planning', 'gestion'],
  'ANIMATION': ['animation', 'distraction', 'jeux', 'activit√©s', 'spectacle'],
  'LUNE_DE_MIEL': ['voyage', 'lune de miel', 'honeymoon', 'destination', 's√©jour'],
  'CADEAUX_INVITES': ['cadeaux', 'souvenirs', 'invit√©s', '√©trennes']
}

// Fonction pour analyser le contenu d'une description
function analyzeDescription(description: string): string[] {
  if (!description) return []
  
  const text = description.toLowerCase()
  const detectedTypes: string[] = []
  
  for (const [serviceType, keywords] of Object.entries(serviceTypeKeywords)) {
    for (const keyword of keywords) {
      if (text.includes(keyword.toLowerCase())) {
        detectedTypes.push(serviceType)
        break // Une fois qu'on trouve un mot-cl√© pour ce type, on passe au suivant
      }
    }
  }
  
  return detectedTypes
}

// Fonction pour analyser le nom de l'entreprise
function analyzeCompanyName(companyName: string): string[] {
  if (!companyName) return []
  
  const name = companyName.toLowerCase()
  const detectedTypes: string[] = []
  
  // Mots-cl√©s sp√©cifiques dans les noms d'entreprise
  const nameKeywords = {
    'PHOTOGRAPHE': ['photo', 'photographe', 'clich√©', 'image'],
    'MUSIQUE': ['music', 'dj', 'son', 'orchestre'],
    'FLORISTE': ['fleur', 'floral', 'rose', 'bouquet'],
    'DECORATION': ['d√©co', 'd√©coration', 'atelier', 'cr√©ation'],
    'TRAITEUR': ['traiteur', 'cuisine', 'gastronomie', 'restaurant'],
    'VOITURE': ['auto', 'voiture', 'v√©hicule', 'location'],
    'VIDEO': ['vid√©o', 'film', 'cin√©ma'],
    'WEDDING_CAKE': ['cake', 'g√¢teau', 'p√¢tisserie'],
    'ORGANISATION': ['event', '√©v√©nement', 'planner', 'organisation']
  }
  
  for (const [serviceType, keywords] of Object.entries(nameKeywords)) {
    for (const keyword of keywords) {
      if (name.includes(keyword.toLowerCase())) {
        detectedTypes.push(serviceType)
        break
      }
    }
  }
  
  return detectedTypes
}

async function analyzeServiceTypes() {
  console.log('üîç Analyse des types de service des 20 premiers partenaires...')
  console.log('================================================================')

  try {
    // R√©cup√©rer les 20 premiers partenaires
    const partners = await prisma.partner.findMany({
      take: 20,
      select: {
        id: true,
        companyName: true,
        description: true,
        shortDescription: true,
        serviceType: true
      },
      orderBy: {
        createdAt: 'asc'
      }
    })

    console.log(`üìä Analyse de ${partners.length} partenaires\n`)

    let errorsFound = 0
    let correctTypes = 0

    for (let i = 0; i < partners.length; i++) {
      const partner = partners[i]
      console.log(`${i + 1}. ${partner.companyName}`)
      console.log(`   Type actuel: ${partner.serviceType}`)
      
      // Analyser la description compl√®te
      const descriptionTypes = analyzeDescription(partner.description)
      
      // Analyser la description courte
      const shortDescriptionTypes = analyzeDescription(partner.shortDescription)
      
      // Analyser le nom de l'entreprise
      const nameTypes = analyzeCompanyName(partner.companyName)
      
      // Combiner tous les types d√©tect√©s
      const allDetectedTypes = [...new Set([...descriptionTypes, ...shortDescriptionTypes, ...nameTypes])]
      
      console.log(`   Types d√©tect√©s dans la description: ${descriptionTypes.length > 0 ? descriptionTypes.join(', ') : 'Aucun'}`)
      console.log(`   Types d√©tect√©s dans le nom: ${nameTypes.length > 0 ? nameTypes.join(', ') : 'Aucun'}`)
      console.log(`   Types sugg√©r√©s: ${allDetectedTypes.length > 0 ? allDetectedTypes.join(', ') : 'Aucun'}`)
      
      // V√©rifier si le type actuel correspond
      const isCorrect = allDetectedTypes.includes(partner.serviceType) || allDetectedTypes.length === 0
      
      if (isCorrect) {
        console.log(`   ‚úÖ Type correct`)
        correctTypes++
      } else {
        console.log(`   ‚ùå ERREUR: Type incorrect`)
        console.log(`   üí° Suggestion: ${allDetectedTypes[0] || 'ORGANISATION'}`)
        errorsFound++
      }
      
      // Afficher un extrait de la description
      const descriptionPreview = partner.description ? 
        partner.description.substring(0, 100).replace(/<[^>]*>/g, '') + '...' : 
        'Aucune description'
      console.log(`   Description: ${descriptionPreview}`)
      
      console.log('')
    }

    console.log('üìà R√âSUM√â DE L\'ANALYSE')
    console.log('======================')
    console.log(`Total analys√©: ${partners.length}`)
    console.log(`Types corrects: ${correctTypes}`)
    console.log(`Erreurs d√©tect√©es: ${errorsFound}`)
    console.log(`Taux d'erreur: ${Math.round((errorsFound / partners.length) * 100)}%`)

    if (errorsFound > 0) {
      console.log('\nüîß RECOMMANDATIONS:')
      console.log('- V√©rifier manuellement les types sugg√©r√©s')
      console.log('- Mettre √† jour les types incorrects dans la base de donn√©es')
      console.log('- Am√©liorer la logique de d√©tection si n√©cessaire')
    }

  } catch (error: any) {
    console.error('üí• Erreur lors de l\'analyse:', error.message)
  } finally {
    await prisma.$disconnect()
  }
}

if (require.main === module) {
  analyzeServiceTypes()
    .then(() => process.exit(0))
    .catch(() => process.exit(1))
}
