import { PrismaClient } from '@prisma/client'
import { list } from '@vercel/blob'

const prisma = new PrismaClient()

async function fixImageUrlsSmart() {
  const startTime = new Date()
  console.log('üöÄ ================================================')
  console.log('üîß CORRECTION INTELLIGENTE DES URLs D\'IMAGES')
  console.log('üöÄ ================================================')
  console.log(`‚è∞ D√©but: ${startTime.toLocaleString()}`)
  
  try {
    // R√©cup√©rer tous les √©tablissements avec leurs images
    const establishments = await prisma.establishment.findMany({
      select: {
        id: true,
        name: true,
        images: true
      }
    })
    
    console.log(`üìä ${establishments.length} √©tablissements √† v√©rifier`)
    console.log(`üéØ Objectif: Corriger toutes les URLs d'images incorrectes`)
    console.log('')
    
    let fixedCount = 0
    let totalChecked = 0
    let skippedCount = 0
    let errorCount = 0
    
    for (const establishment of establishments) {
      totalChecked++
      
      // Logs de progr√®s d√©taill√©s
      if (totalChecked % 50 === 0) {
        const elapsed = new Date().getTime() - startTime.getTime()
        const elapsedMinutes = Math.floor(elapsed / 60000)
        const elapsedSeconds = Math.floor((elapsed % 60000) / 1000)
        const rate = totalChecked / (elapsed / 1000) // √©tablissements par seconde
        const estimatedTotal = establishments.length / rate // temps total estim√© en secondes
        const remaining = Math.max(0, estimatedTotal - elapsed / 1000)
        const remainingMinutes = Math.floor(remaining / 60)
        const remainingSeconds = Math.floor(remaining % 60)
        
        console.log('')
        console.log('üìà ========== RAPPORT DE PROGR√àS ==========')
        console.log(`‚è±Ô∏è  Temps √©coul√©: ${elapsedMinutes}m ${elapsedSeconds}s`)
        console.log(`üìä Progr√®s: ${totalChecked}/${establishments.length} (${((totalChecked/establishments.length)*100).toFixed(1)}%)`)
        console.log(`‚úÖ Corrig√©s: ${fixedCount}`)
        console.log(`‚è≠Ô∏è  Ignor√©s: ${skippedCount}`)
        console.log(`‚ùå Erreurs: ${errorCount}`)
        console.log(`üöÄ Vitesse: ${rate.toFixed(2)} √©tablissements/seconde`)
        console.log(`‚è≥ Temps restant estim√©: ${remainingMinutes}m ${remainingSeconds}s`)
        console.log('==========================================')
        console.log('')
      }
      
      if (!establishment.images || establishment.images.length === 0) {
        skippedCount++
        continue
      }
      
      // Construire le pr√©fixe du dossier pour cet √©tablissement
      const folderPrefix = `establishments/${establishment.id}/960/`
      
      try {
        // Lister tous les fichiers dans le dossier de cet √©tablissement
        const { blobs } = await list({
          prefix: folderPrefix,
          limit: 100
        })
        
        if (blobs.length === 0) {
          console.log(`‚ö†Ô∏è  [${totalChecked}/${establishments.length}] Aucun fichier trouv√© pour ${establishment.name}`)
          skippedCount++
          continue
        }
        
        // Cr√©er un mapping des fichiers existants
        const existingFiles = new Map<string, string>()
        blobs.forEach(blob => {
          const fileName = blob.url.split('/').pop() || ''
          const imageNumber = extractImageNumber(fileName)
          if (imageNumber !== null) {
            existingFiles.set(imageNumber.toString(), blob.url)
          }
        })
        
        // Corriger les URLs
        const correctedImages: string[] = []
        let hasChanges = false
        
        for (let i = 0; i < establishment.images.length; i++) {
          const originalUrl = establishment.images[i]
          
          // V√©rifier si l'URL originale fonctionne
          try {
            const response = await fetch(originalUrl, { method: 'HEAD' })
            if (response.ok) {
              correctedImages.push(originalUrl)
              continue
            }
          } catch (error) {
            // URL ne fonctionne pas, essayer de la corriger
          }
          
          // Chercher un fichier correspondant dans les fichiers existants
          const imageNumber = i + 1
          const existingFile = existingFiles.get(imageNumber.toString())
          
          if (existingFile) {
            correctedImages.push(existingFile)
            hasChanges = true
          } else {
            // Garder l'URL originale m√™me si elle ne fonctionne pas
            correctedImages.push(originalUrl)
          }
        }
        
        // Mettre √† jour la base de donn√©es si des changements ont √©t√© faits
        if (hasChanges) {
          try {
            await prisma.establishment.update({
              where: { id: establishment.id },
              data: { images: correctedImages }
            })
            fixedCount++
            
            if (fixedCount % 10 === 0) {
              console.log(`‚úÖ [${totalChecked}/${establishments.length}] ${fixedCount} √©tablissements corrig√©s`)
            }
          } catch (error) {
            console.error(`‚ùå [${totalChecked}/${establishments.length}] Erreur lors de la mise √† jour de ${establishment.name}:`, error)
            errorCount++
          }
        }
        
      } catch (error) {
        console.error(`‚ùå [${totalChecked}/${establishments.length}] Erreur lors de la v√©rification de ${establishment.name}:`, error)
        errorCount++
      }
      
      // D√©lai pour √©viter de surcharger l'API
      await new Promise(resolve => setTimeout(resolve, 200))
    }
    
    const endTime = new Date()
    const totalTime = endTime.getTime() - startTime.getTime()
    const totalMinutes = Math.floor(totalTime / 60000)
    const totalSeconds = Math.floor((totalTime % 60000) / 1000)
    
    console.log('')
    console.log('üéâ ========== CORRECTION TERMIN√âE ==========')
    console.log(`‚è∞ D√©but: ${startTime.toLocaleString()}`)
    console.log(`‚è∞ Fin: ${endTime.toLocaleString()}`)
    console.log(`‚è±Ô∏è  Dur√©e totale: ${totalMinutes}m ${totalSeconds}s`)
    console.log(`üìä R√©sultats:`)
    console.log(`   ‚Ä¢ Total v√©rifi√©s: ${totalChecked}/${establishments.length}`)
    console.log(`   ‚Ä¢ Corrig√©s: ${fixedCount}`)
    console.log(`   ‚Ä¢ Ignor√©s: ${skippedCount}`)
    console.log(`   ‚Ä¢ Erreurs: ${errorCount}`)
    console.log(`üìà Taux de succ√®s: ${((fixedCount/totalChecked)*100).toFixed(1)}%`)
    console.log(`üöÄ Vitesse moyenne: ${(totalChecked/(totalTime/1000)).toFixed(2)} √©tablissements/seconde`)
    console.log('==========================================')
    console.log('')
    
  } catch (error) {
    console.error('‚ùå Erreur fatale:', error)
  } finally {
    await prisma.$disconnect()
  }
}

function extractImageNumber(fileName: string): number | null {
  // Extraire le num√©ro d'image du nom de fichier
  // Formats support√©s: image-1.webp, image-1-hash.webp, image1.webp, img-1.webp, etc.
  const patterns = [
    /image-(\d+)/,
    /image(\d+)/,
    /img-(\d+)/,
    /img(\d+)/
  ]
  
  for (const pattern of patterns) {
    const match = fileName.match(pattern)
    if (match) {
      return parseInt(match[1])
    }
  }
  
  return null
}

fixImageUrlsSmart()
